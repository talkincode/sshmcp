
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sshx/internal/app/app.go (31.4%)</option>
				
				<option value="file1">sshx/internal/app/config.go (94.7%)</option>
				
				<option value="file2">sshx/internal/app/password.go (2.9%)</option>
				
				<option value="file3">sshx/internal/app/usage.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "errors"
        "fmt"
        "io"
        "log"
        "strings"

        "github.com/joho/godotenv"

        "sshx/internal/mcp"
        "sshx/internal/sshclient"
)

// ErrUsage is returned when only the usage information was printed.
var ErrUsage = errors.New("usage displayed")

// Run executes the CLI using the provided arguments (typically os.Args).
func Run(args []string) error <span class="cov10" title="3">{
        // Handle MCP stdio mode
        if len(args) &gt;= 2 &amp;&amp; (args[1] == "mcp-stdio" || args[1] == "--mcp-stdio") </span><span class="cov0" title="0">{
                log.SetOutput(io.Discard)

                server := mcp.NewMCPServer()
                if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Handle usage
        <span class="cov10" title="3">if len(args) &lt; 2 </span><span class="cov6" title="2">{
                PrintUsage()
                return ErrUsage
        }</span>

        // Load environment variables
        <span class="cov1" title="1">_ = godotenv.Load()

        // Parse command-line arguments
        config := ParseArgs(args)

        // Handle password management mode
        if config.Mode == "password" </span><span class="cov0" title="0">{
                if err := HandlePasswordManagement(config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("password management failed: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Auto-fill sudo password if needed
        <span class="cov1" title="1">if strings.Contains(config.Command, "sudo") &amp;&amp; config.SudoKey != "" </span><span class="cov0" title="0">{
                password, err := sshclient.GetSudoPassword(config.SudoKey)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to get sudo password from keyring: %v", err)
                        log.Println("Continuing without sudo password auto-fill...")
                }</span> else<span class="cov0" title="0"> {
                        config.Password = password
                        log.Printf("✓ Sudo password will be auto-filled when prompted")
                }</span>
        }

        // Create SSH client
        <span class="cov1" title="1">client, err := sshclient.NewSSHClient(config)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create SSH client: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Connect to remote host
        if err := client.Connect(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect: %w", err)
        }</span>

        // Handle SFTP mode
        <span class="cov0" title="0">if config.Mode == "sftp" </span><span class="cov0" title="0">{
                if err := client.ExecuteSftp(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("SFTP operation failed: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Handle SSH command execution
        <span class="cov0" title="0">if err := client.ExecuteCommand(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute command: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "os"
        "strings"

        "sshx/internal/sshclient"
)

// ParseArgs parses command-line arguments and returns a Config.
func ParseArgs(args []string) *sshclient.Config <span class="cov8" title="28">{
        config := &amp;sshclient.Config{
                Command:     strings.Join(args[1:], " "),
                Mode:        "ssh",
                SafetyCheck: true,
                Force:       false,
        }

        if password := os.Getenv("SSH_PASSWORD"); password != "" </span><span class="cov1" title="1">{
                config.Password = password
        }</span>
        <span class="cov8" title="28">if keyPath := os.Getenv("SSH_KEY_PATH"); keyPath != "" </span><span class="cov1" title="1">{
                config.KeyPath = keyPath
        }</span>

        <span class="cov8" title="28">if os.Getenv("SSH_NO_SAFETY_CHECK") == "true" </span><span class="cov1" title="1">{
                config.SafetyCheck = false
        }</span>
        <span class="cov8" title="28">if os.Getenv("SSH_FORCE") == "true" </span><span class="cov1" title="1">{
                config.Force = true
        }</span>

        <span class="cov8" title="28">sudoKey := os.Getenv("SSH_SUDO_KEY")
        if sudoKey == "" </span><span class="cov8" title="27">{
                sudoKey = sshclient.DefaultSudoKey
        }</span>
        <span class="cov8" title="28">config.SudoKey = sudoKey

        for i := 1; i &lt; len(args); i++ </span><span class="cov10" title="57">{
                arg := args[i]
                switch </span>{
                case strings.HasPrefix(arg, "-h="), strings.HasPrefix(arg, "--host="):<span class="cov7" title="18">
                        config.Host = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "-p="), strings.HasPrefix(arg, "--port="):<span class="cov2" title="2">
                        config.Port = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "-u="), strings.HasPrefix(arg, "--user="):<span class="cov2" title="2">
                        config.User = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "-i="), strings.HasPrefix(arg, "--key="):<span class="cov2" title="2">
                        config.KeyPath = strings.SplitN(arg, "=", 2)[1]</span>
                case arg == "--force", arg == "-f":<span class="cov2" title="2">
                        config.Force = true</span>
                case arg == "--no-safety-check":<span class="cov1" title="1">
                        config.SafetyCheck = false</span>
                case arg == "--sftp":<span class="cov0" title="0">
                        config.Mode = "sftp"</span>
                case strings.HasPrefix(arg, "--upload="):<span class="cov1" title="1">
                        config.Mode = "sftp"
                        config.SftpAction = "upload"
                        config.LocalPath = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "--download="):<span class="cov1" title="1">
                        config.Mode = "sftp"
                        config.SftpAction = "download"
                        config.RemotePath = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "--to="):<span class="cov2" title="2">
                        if config.SftpAction == "upload" </span><span class="cov1" title="1">{
                                config.RemotePath = strings.SplitN(arg, "=", 2)[1]
                        }</span> else<span class="cov1" title="1"> if config.SftpAction == "download" </span><span class="cov1" title="1">{
                                config.LocalPath = strings.SplitN(arg, "=", 2)[1]
                        }</span>
                case strings.HasPrefix(arg, "--list="), strings.HasPrefix(arg, "--ls="):<span class="cov2" title="2">
                        config.Mode = "sftp"
                        config.SftpAction = "list"
                        config.RemotePath = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "--mkdir="):<span class="cov1" title="1">
                        config.Mode = "sftp"
                        config.SftpAction = "mkdir"
                        config.RemotePath = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "--rm="):<span class="cov1" title="1">
                        config.Mode = "sftp"
                        config.SftpAction = "remove"
                        config.RemotePath = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "--password-set="):<span class="cov2" title="2">
                        config.Mode = "password"
                        config.PasswordAction = "set"
                        parts := strings.SplitN(arg, "=", 2)
                        if len(parts) &gt; 1 </span><span class="cov2" title="2">{
                                keyValue := strings.SplitN(parts[1], ":", 2)
                                config.PasswordKey = keyValue[0]
                                if len(keyValue) &gt; 1 </span><span class="cov1" title="1">{
                                        config.PasswordValue = keyValue[1]
                                }</span>
                        }
                case strings.HasPrefix(arg, "--password-get="):<span class="cov1" title="1">
                        config.Mode = "password"
                        config.PasswordAction = "get"
                        config.PasswordKey = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "--password-delete="), strings.HasPrefix(arg, "--password-del="):<span class="cov2" title="2">
                        config.Mode = "password"
                        config.PasswordAction = "delete"
                        config.PasswordKey = strings.SplitN(arg, "=", 2)[1]</span>
                case strings.HasPrefix(arg, "--password-check="), strings.HasPrefix(arg, "--password-exists="):<span class="cov2" title="2">
                        config.Mode = "password"
                        config.PasswordAction = "check"
                        config.PasswordKey = strings.SplitN(arg, "=", 2)[1]</span>
                case arg == "--password-list" || arg == "--password-ls":<span class="cov2" title="2">
                        config.Mode = "password"
                        config.PasswordAction = "list"</span>
                case arg == "--help":<span class="cov0" title="0">
                        PrintUsage()
                        os.Exit(0)</span>
                default:<span class="cov6" title="13">
                        if config.Mode == "ssh" &amp;&amp; config.Command == "" </span><span class="cov0" title="0">{
                                config.Command = arg
                        }</span>
                }
        }

        <span class="cov8" title="28">if config.Mode == "ssh" </span><span class="cov6" title="13">{
                actualCmd := []string{}
                for i := 1; i &lt; len(args); i++ </span><span class="cov8" title="34">{
                        arg := args[i]
                        if strings.HasPrefix(arg, "-") </span><span class="cov7" title="21">{
                                continue</span>
                        }
                        <span class="cov6" title="13">actualCmd = append(actualCmd, arg)</span>
                }

                <span class="cov6" title="13">if len(actualCmd) &gt; 0 </span><span class="cov6" title="13">{
                        config.Command = strings.Join(actualCmd, " ")
                }</span>
        }

        <span class="cov8" title="28">return config</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "fmt"
        "log"
        "os"
        "strings"

        "github.com/zalando/go-keyring"

        "sshx/internal/sshclient"
)

// HandlePasswordManagement handles all password management operations.
func HandlePasswordManagement(config *sshclient.Config) error <span class="cov0" title="0">{
        switch config.PasswordAction </span>{
        case "set":<span class="cov0" title="0">
                return setPassword(sshclient.KeyringServiceName, config.PasswordKey, config.PasswordValue)</span>
        case "get":<span class="cov0" title="0">
                return getPassword(sshclient.KeyringServiceName, config.PasswordKey)</span>
        case "delete", "del", "rm":<span class="cov0" title="0">
                return deletePassword(sshclient.KeyringServiceName, config.PasswordKey)</span>
        case "list", "ls":<span class="cov0" title="0">
                return listPasswords()</span>
        case "check", "exists":<span class="cov0" title="0">
                return checkPassword(sshclient.KeyringServiceName, config.PasswordKey)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown password action: %s (use: set, get, delete, list, check)", config.PasswordAction)</span>
        }
}

func setPassword(serviceName, key, value string) error <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("password key is required")
        }</span>
        <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                fmt.Printf("Enter password for key '%s': ", key)
                password, err := readPassword()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read password: %w", err)
                }</span>
                <span class="cov0" title="0">value = password</span>
        }

        <span class="cov0" title="0">if err := keyring.Set(serviceName, key, value); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set password: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("✓ Password saved to system keyring")
        log.Printf("  Service: %s", serviceName)
        log.Printf("  Key: %s", key)

        fmt.Println("\nVerify with:")
        if isWindows() </span><span class="cov0" title="0">{
                fmt.Println("  Windows: Check Credential Manager -&gt; Generic Credentials")
        }</span> else<span class="cov0" title="0"> if isMacOS() </span><span class="cov0" title="0">{
                fmt.Printf("  macOS: security find-generic-password -s %s -a %s -w\n", serviceName, key)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  Linux: secret-tool lookup service %s username %s\n", serviceName, key)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getPassword(serviceName, key string) error <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("password key is required")
        }</span>

        <span class="cov0" title="0">password, err := keyring.Get(serviceName, key)
        if err != nil </span><span class="cov0" title="0">{
                if err == keyring.ErrNotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("password not found for key: %s", key)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get password: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("✓ Password retrieved from system keyring")
        log.Printf("  Service: %s", serviceName)
        log.Printf("  Key: %s", key)
        fmt.Printf("\nPassword: %s\n", password)

        return nil</span>
}

func deletePassword(serviceName, key string) error <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("password key is required")
        }</span>

        <span class="cov0" title="0">_, err := keyring.Get(serviceName, key)
        if err != nil </span><span class="cov0" title="0">{
                if err == keyring.ErrNotFound </span><span class="cov0" title="0">{
                        log.Printf("Password not found for key: %s (already deleted or never existed)", key)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to check password: %w", err)</span>
        }

        <span class="cov0" title="0">if err := keyring.Delete(serviceName, key); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete password: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("✓ Password deleted from system keyring")
        log.Printf("  Service: %s", serviceName)
        log.Printf("  Key: %s", key)

        return nil</span>
}

func checkPassword(serviceName, key string) error <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("password key is required")
        }</span>

        <span class="cov0" title="0">_, err := keyring.Get(serviceName, key)
        if err == nil </span><span class="cov0" title="0">{
                log.Printf("✓ Password exists for key: %s", key)
                fmt.Printf("\nKey '%s' is stored in system keyring\n", key)
                fmt.Printf("Service: %s\n", serviceName)
                return nil
        }</span>

        <span class="cov0" title="0">if err == keyring.ErrNotFound </span><span class="cov0" title="0">{
                log.Printf("✗ Password not found for key: %s", key)
                fmt.Printf("\nKey '%s' is NOT stored in system keyring\n", key)
                fmt.Printf("Use 'sshx --password-set=%s' to add it\n", key)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("failed to check password: %w", err)</span>
}

func listPasswords() error <span class="cov0" title="0">{
        fmt.Println("Checking password keys in system keyring...")
        fmt.Println("Service:", sshclient.KeyringServiceName)
        fmt.Println()

        commonKeys := []string{
                "ma8",
                "sudo",
                "root",
                "admin",
                "password",
        }

        fmt.Println("Common keys:")
        found := false
        for _, key := range commonKeys </span><span class="cov0" title="0">{
                _, err := keyring.Get(sshclient.KeyringServiceName, key)
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("  ✓ %s (exists)\n", key)
                        found = true
                }</span> else<span class="cov0" title="0"> if err == keyring.ErrNotFound </span><span class="cov0" title="0">{
                        fmt.Printf("    %s (not set)\n", key)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  ? %s (error: %v)\n", key, err)
                }</span>
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                fmt.Println("  (no common keys found)")
        }</span>

        <span class="cov0" title="0">fmt.Println("\nNote: This list only shows predefined common keys.")
        fmt.Println("Custom password keys you've set (like 'test-password') are stored")
        fmt.Println("but not listed here due to keyring API limitations.")
        fmt.Println("\nTo check a custom key:")
        fmt.Println("  sshx --password-get=&lt;your-key-name&gt;")
        fmt.Println("\nPlatform-specific commands to list all:")
        if isMacOS() </span><span class="cov0" title="0">{
                fmt.Println("  macOS: security find-generic-password -s sshx")
        }</span> else<span class="cov0" title="0"> if isWindows() </span><span class="cov0" title="0">{
                fmt.Println("  Windows: Control Panel -&gt; Credential Manager -&gt; Generic Credentials")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("  Linux: Use your desktop's keyring manager (Seahorse, KWalletManager, etc.)")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func readPassword() (string, error) <span class="cov0" title="0">{
        var password string
        fmt.Print("\n")
        _, err := fmt.Scanln(&amp;password)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(password), nil</span>
}

func isWindows() bool <span class="cov10" title="4">{
        return strings.Contains(strings.ToLower(os.Getenv("OS")), "windows")
}</span>

func isMacOS() bool <span class="cov1" title="1">{
        if _, err := os.Stat("/Applications"); err == nil </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import "fmt"

// PrintUsage prints the usage information for the sshx command.
func PrintUsage() <span class="cov10" title="5">{
        fmt.Println(`
SSH &amp; SFTP Remote Tool with Password Manager (Cross-Platform)

Usage:
  sshx mcp-stdio                                  # MCP stdio mode (for AI assistants)
  sshx -h=&lt;host&gt; [options] &lt;command&gt;              # SSH mode
  sshx -h=&lt;host&gt; [options] --upload=&lt;file&gt;        # SFTP upload
  sshx -h=&lt;host&gt; [options] --download=&lt;file&gt;      # SFTP download
  sshx --password-set=&lt;key&gt;[:&lt;value&gt;]             # Password management
  sshx --password-get=&lt;key&gt;                       # Get password
  sshx --password-list                            # List passwords

MCP Mode:
  sshx mcp-stdio            Start MCP server in stdio mode
  sshx --mcp-stdio          Alternative MCP mode flag

  MCP Tools Available:
    - ssh_execute           Execute SSH commands with sudo support
    - sftp_upload           Upload files via SFTP
    - sftp_download         Download files via SFTP
    - sftp_list             List directory contents
    - sftp_mkdir            Create remote directory
    - sftp_remove           Remove files/directories
    - password_set          Store password in system keyring
    - password_get          Retrieve password from keyring
    - password_delete       Delete password from keyring
    - password_list         List common password keys

SSH Options:
  -h, --host=HOST       Remote host address (required)
  -p, --port=PORT       SSH port (default: 22)
  -u, --user=USER       SSH username (default: master)
  -i, --key=PATH        SSH private key path (default: ~/.ssh/id_rsa)
  --help                Show this help message

Safety Options:
  -f, --force           Force execution, bypass safety checks (use with caution!)
  --no-safety-check     Disable safety checks completely (not recommended)

  Safety checks protect against:
    - Destructive operations (rm -rf /, mkfs, dd)
    - System shutdown/reboot commands
    - Critical file modifications (/etc/passwd, /etc/shadow)
    - Dangerous pipe operations (curl | sh)
    - Fork bombs and other malicious patterns

SFTP Options:
  --upload=&lt;local&gt;      Upload file (use with --to=&lt;remote&gt;)
  --download=&lt;remote&gt;   Download file (use with --to=&lt;local&gt;)
  --to=&lt;path&gt;           Target path for upload/download
  --list=&lt;path&gt;         List directory contents (alias: --ls)
  --mkdir=&lt;path&gt;        Create remote directory
  --rm=&lt;path&gt;           Remove remote file or directory

Password Management (Cross-Platform):
  --password-set=&lt;key&gt;[:&lt;password&gt;]   Set password in system keyring
                                      If password omitted, will prompt
  --password-get=&lt;key&gt;                Get password from keyring
  --password-check=&lt;key&gt;              Check if password exists (alias: --password-exists)
  --password-delete=&lt;key&gt;             Delete password from keyring (alias: --password-del)
  --password-list                     List common password keys (alias: --password-ls)

  Platform Support:
    macOS:   Uses Keychain
    Linux:   Uses Secret Service (gnome-keyring/kwallet)
    Windows: Uses Credential Manager

Environment Variables (.env):
  SSH_PASSWORD          SSH password (not recommended, use SSH keys or keyring)
  SSH_KEY_PATH          SSH private key path
  SSH_SUDO_KEY          Sudo password keyring key name (default: ma8)
  SSH_NO_SAFETY_CHECK   Disable safety checks (true/false)
  SSH_FORCE             Force execution mode (true/false)

SSH Examples:
  # Execute simple command (default user: master)
  sshx -h=192.168.1.100 "uptime"

  # Execute sudo command (auto password from keyring: ma8)
  sshx -h=192.168.1.100 "sudo systemctl status docker"

  # Custom SSH port
  sshx -h=192.168.1.100 -p=2222 "ps aux | grep nginx"

  # Dangerous command will be blocked
  sshx -h=192.168.1.100 "sudo rm -rf /tmp/*"  # Safe
  sshx -h=192.168.1.100 "sudo rm -rf /"       # ⚠️ BLOCKED!

  # Force execute (bypass safety check - use with caution!)
  sshx -h=192.168.1.100 --force "sudo reboot"
  sshx -h=192.168.1.100 -f "sudo systemctl reboot"

SFTP Examples:
  # Upload file
  sshx -h=192.168.1.100 --upload=local.txt --to=/tmp/remote.txt

  # Download file
  sshx -h=192.168.1.100 --download=/var/log/app.log --to=./app.log

  # List directory
  sshx -h=192.168.1.100 --list=/var/log

  # Create directory
  sshx -h=192.168.1.100 --mkdir=/tmp/newdir

  # Remove file
  sshx -h=192.168.1.100 --rm=/tmp/oldfile.txt

  # Batch upload
  for file in *.txt; do
    sshx -h=192.168.1.100 --upload=$file --to=/backup/$file
  done

Password Management Examples:
  # Set sudo password (interactive prompt)
  sshx --password-set=ma8

  # Set sudo password (inline, not recommended for security)
  sshx --password-set=ma8:mypassword

  # Set custom password
  sshx --password-set=myserver

  # Get password
  sshx --password-get=ma8

  # Check if password exists
  sshx --password-check=test-password

  # List common password keys
  sshx --password-list

  # Delete password
  sshx --password-delete=ma8

  # Set password for specific server
  sshx --password-set=prod-server:secretpass
  sshx -h=prod-server "sudo reboot"  # Will use ENV SSH_SUDO_KEY or ma8

Note:
  - SSH key authentication is tried first, then password authentication
  - Sudo password is automatically retrieved from system keyring
  - SFTP operations use the same SSH connection
  - Password manager works across macOS/Linux/Windows
  - Default user: master, Default sudo key: ma8`)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
